<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <title>Document Editor</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
    <!-- MathJax 라이브러리 추가 -->
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" defer></script>
    <style>
        /* 수정된 스타일 */
        .equation {
            background-color: #2c2c2c; /* 어두운 배경 */
            color: white; /* 흰색 텍스트 */
            padding: 10px;
            border-left: 3px solid #4CAF50;
            cursor: default;
        }

        .equation:hover {
            background-color: #3d3d3d;
        }

        /* MathJax 수식이 흰색으로 표시되도록 설정 */
        .equation .MathJax {
            color: inherit;
        }

        .equation .mjx-chtml {
            color: inherit !important;
        }
    </style>
</head>

<body>
    <!-- 네비게이션 바 -->
    <nav>
        <ul>
            <li><a href="/">Home</a></li>
            <li><a href="/editor">Editor</a></li>
        </ul>
    </nav>

    <!-- 에디터 컨테이너 -->
    <div id="editor-container">
        <!-- 초기 editable div -->
        <div class="editable" contenteditable="true">
            여기에 입력하세요... 여기서도 뭔가 문장의 엱ㅇ이 이루어질 수 있다는 사실이 내 감정을 불쾌하게 만들었다
        </div>
        <!-- 커서 위치를 표시할 요소 -->
        <div id="caret-position">커서 위치: X=0px, Y=0px</div>
    </div>

    <!-- 메인 스크립트: utils.js 모듈 가져오기 -->
    <script type="module">
        import {
            getCaretCoordinates,
            findPreviousEditableDiv,
            findNextEditableDiv,
            setCursorToStart,
            setCursorToEnd,
            isCursorOnFirstLine,
            isCursorOnLastLine,
            setCursorClosestToX,
            getCaretCharacterOffsetWithin,
            setCaretPosition
        } from './utils.js';

        // 요소 선택
        const editorContainer = document.getElementById('editor-container');
        const caretPosition = document.getElementById('caret-position');

        // 구성 상태를 추적하는 플래그
        let isComposing = false;

        // 원하는 X 좌표를 저장하는 변수
        let desiredX = 0;

        // HTML Fragment를 문자열로 변환하는 유틸리티 함수
        function fragmentToHTML(fragment) {
            const div = document.createElement('div');
            div.appendChild(fragment.cloneNode(true));
            return div.innerHTML;
        }

        /**
         * 커서 위치를 업데이트하고 desiredX를 저장하는 핸들러 함수
         * @param {HTMLElement} editable - 현재 포커스된 editable div
         */
        function handleCaretPosition(editable) {
            const coords = getCaretCoordinates(editable, caretPosition);
            desiredX = coords.x;
        }

        /**
         * 새로운 editable div를 생성하여 에디터 컨테이너에 추가하는 함수
         * @param {HTMLElement} referenceDiv - 새로운 div를 삽입할 기준이 되는 div
         * @param {string} [content] - 새로운 div에 추가할 초기 내용
         * @returns {HTMLElement} - 생성된 editable div
         */
        function createNewEditableDiv(referenceDiv, content = '') {
            const newDiv = document.createElement('div');
            newDiv.classList.add('editable');
            newDiv.setAttribute('contenteditable', 'true');
            newDiv.innerHTML = content ? content : '\u200b'; // 빈 div는 제로 폭 공백 추가

            // referenceDiv의 다음 형제로 삽입
            referenceDiv.parentNode.insertBefore(newDiv, referenceDiv.nextSibling);

            return newDiv;
        }

        /**
         * 수식 칸으로 변환하는 함수
         * @param {HTMLElement} editable - 수식 칸으로 변환할 div
         */
        function transformToEquationDiv(editable) {
            const content = editable.textContent.trim();
            if (content.startsWith('/')) {
                const latex = content.substring(1).trim();
                if (latex.length > 0) {
                    renderEquation(editable, latex);
                }
            } else {
                // '/'로 시작하지 않으면 기존 방식대로 수식 칸으로 변환
                editable.classList.add('equation'); // 수식 칸 스타일 추가
                editable.setAttribute('contenteditable', 'false'); // 편집 비활성화
                editable.innerHTML = '<span>수식을 입력하세요...</span>'; // 초기 수식 텍스트
            }
        }

        /**
         * 새로 생성된 editable div로 커서를 이동시키는 함수
         * @param {HTMLElement} editable - 커서를 이동시킬 editable div
         * @param {string} position - 'start' 또는 'end'
         */
        function moveCursorToEditable(editable, position = 'start') {
            setTimeout(() => {
                editable.focus();
                if (position === 'start') {
                    setCursorToStart(editable);
                } else if (position === 'end') {
                    setCursorToEnd(editable);
                }
            }, 0);
        }

        /**
         * 엔터키 처리를 위한 핸들러 함수
         * @param {KeyboardEvent} event - 키보드 이벤트
         * @param {HTMLElement} editable - 현재 포커스된 editable div
         */
        function handleEnterKey(event, editable) {
            if (event.key === 'Enter') {
                event.preventDefault(); // 기본 엔터키 동작 방지

                try {
                    // 현재 선택 영역 가져오기
                    const selection = window.getSelection();
                    if (!selection.rangeCount) {
                        console.warn('No selection range available');
                        return;
                    }

                    const range = selection.getRangeAt(0).cloneRange();

                    const caretPosition = getCaretCharacterOffsetWithin(editable);

                    // editable div의 시작부터 현재 커서 위치까지의 범위 생성 (beforeRange)
                    const beforeRange = range.cloneRange();
                    beforeRange.selectNodeContents(editable);
                    beforeRange.setEnd(range.startContainer, range.startOffset);

                    // 현재 커서 위치부터 editable div의 끝까지의 범위 생성 (afterRange)
                    const afterRange = range.cloneRange();
                    afterRange.selectNodeContents(editable);
                    afterRange.setStart(range.startContainer, range.startOffset);

                    // before 콘텐츠 추출 및 HTML로 변환
                    const beforeFragment = beforeRange.cloneContents();
                    const beforeContent = fragmentToHTML(beforeFragment);

                    // after 콘텐츠 추출 및 HTML로 변환
                    const afterFragment = afterRange.cloneContents();
                    const afterContent = fragmentToHTML(afterFragment);

                    // 기존 editable div의 내용을 beforeContent로 업데이트
                    editable.innerHTML = beforeContent;

                    // 새로운 editable div 생성 및 afterContent 설정
                    const newEditable = createNewEditableDiv(editable, afterContent);

                    // 상태 캡처 후 DOM 변경
                    setTimeout(() => {
                        // 커서를 새로운 div로 이동
                        moveCursorToEditable(newEditable, 'start');
                    }, 0);

                } catch (error) {
                    console.error('handleEnterKey error:', error);
                }
            }
        }

        /**
         * 백스페이스 키 처리를 위한 핸들러 함수
         * @param {KeyboardEvent} event - 키보드 이벤트
         * @param {HTMLElement} editable - 현재 포커스된 editable div
         */
        function handleBackspaceKey(event, editable) {
            if (event.key === 'Backspace') {
                // editable div의 내용이 비어있거나 제로 폭 공백만 있는지 확인
                const content = editable.innerHTML.trim();
                if (content === '' || content === '\u200b') {
                    event.preventDefault(); // 기본 백스페이스 동작 방지

                    const previousDiv = findPreviousEditableDiv(editable);
                    const parent = editable.parentNode;

                    // 현재 editable div 삭제
                    parent.removeChild(editable);

                    if (previousDiv) {
                        // 이전 div가 있을 경우 커서를 이전 div의 끝으로 이동
                        setTimeout(() => {
                            moveCursorToEditable(previousDiv, 'end');
                            // 상태 캡처 및 저장 (captureEditorState 및 undoManager는 별도로 구현 필요)
                            if (typeof captureEditorState === 'function' && undoManager) {
                                const prevState = captureEditorState(previousDiv);
                                undoManager.pushState(prevState);
                                console.log('State pushed to undoManager after Backspace');
                            }
                        }, 0);
                    } else {
                        // 이전 div가 없을 경우 새로운 빈 div 생성 및 커서 이동
                        const newEditable = createNewEditableDiv(parent, '');
                        setTimeout(() => {
                            moveCursorToEditable(newEditable, 'start');
                        }, 0);
                    }
                }
            }
        }

        /**
         * LaTeX 수식을 렌더링하여 editable div에 삽입하는 함수
         * @param {HTMLElement} editable - 수식을 렌더링할 div
         * @param {string} latex - LaTeX 수식 문자열
         */
        function renderEquation(editable, latex) {
            editable.classList.add('equation'); // 수식 스타일 추가
            editable.setAttribute('contenteditable', 'false'); // 편집 비활성화
            editable.dataset.latex = latex; // LaTeX 코드 저장
            editable.innerHTML = `\\[${latex}\\]`; // LaTeX 수식 삽입

            // MathJax 재렌더링 트리거
            MathJax.typesetPromise([editable]).then(() => {
                console.log('MathJax 렌더링 완료');
            }).catch((err) => console.error('MathJax 렌더링 에러:', err));
        }

        /**
         * 커서가 div를 벗어날 때 수식을 렌더링하는 함수
         * @param {HTMLElement} editable - 포커스를 잃은 editable div
         */
        function handleFocusOut(editable) {
            const content = editable.textContent.trim();
            if (content.startsWith('/')) {
                const latex = content.substring(1).trim();
                if (latex.length > 0) {
                    renderEquation(editable, latex);
                }
            }
        }

        /**
         * 수식 렌더링된 div를 편집 가능하도록 변환하는 함수
         * @param {HTMLElement} equationDiv - 수식 렌더링된 div
         */
        function transformToEditableDiv(equationDiv) {
            const latex = equationDiv.dataset.latex || '';
            equationDiv.classList.remove('equation'); // 수식 클래스 제거
            equationDiv.setAttribute('contenteditable', 'true'); // 편집 가능으로 설정
            equationDiv.innerHTML = `/${latex}`; // '/'로 시작하는 LaTeX 코드 삽입
            equationDiv.removeAttribute('data-latex'); // 데이터 속성 제거
            equationDiv.focus(); // 포커스 설정
            setCursorToEnd(equationDiv); // 커서를 끝으로 이동
        }

        /**
         * 이벤트 위임을 사용하여 모든 editable div에 대해 이벤트 핸들링
         */
        editorContainer.addEventListener('keydown', (event) => {
            const target = event.target;
            if (!target.classList.contains('editable')) return;

            if ((event.ctrlKey || event.metaKey) && event.key === 'Enter') {
                if (isComposing) {
                    // 구성 중일 때는 엔터키 처리하지 않음
                    return;
                }
                handleEnterKey(event, target);
            }
            else if (event.key === 'ArrowUp') {
                if (isComposing) return;

                // 커서가 첫 번째 줄에 있는지 확인
                const onFirstLine = isCursorOnFirstLine(target);

                if (onFirstLine) {
                    event.preventDefault();
                    const previousDiv = findPreviousEditableDiv(target);
                    if (previousDiv) {
                        // 이전 div의 마지막 위치로 커서 설정
                        setCursorClosestToX(previousDiv, desiredX, 'last');

                        // 만약 이전 div가 수식 div라면 편집 모드로 전환
                        if (previousDiv.classList.contains('equation')) {
                            transformToEditableDiv(previousDiv);
                        }
                    }
                }
                // else: 기본 동작 수행 (커서를 위로 이동)
            }
            else if (event.key === 'ArrowDown') {
                if (isComposing) return;

                // 커서가 마지막 줄에 있는지 확인
                const onLastLine = isCursorOnLastLine(target);

                if (onLastLine) {
                    event.preventDefault();
                    const nextDiv = findNextEditableDiv(target);
                    if (nextDiv) {
                        // 다음 div의 첫 번째 위치로 커서 설정
                        setCursorClosestToX(nextDiv, desiredX, 'first');

                        // 만약 다음 div가 수식 div라면 편집 모드로 전환
                        if (nextDiv.classList.contains('equation')) {
                            transformToEditableDiv(nextDiv);
                        }
                    }
                }
                // else: 기본 동작 수행 (커서를 아래로 이동)
            }
            else if (event.key === 'Backspace') {
                if (isComposing) return;
                handleBackspaceKey(event, target);
            }
            else if (event.key === '/' && target.innerHTML.trim() === '') {
                event.preventDefault(); // 기본 동작 방지
                // 사용자가 '/'를 입력하면 해당 div를 수식 입력 모드로 전환
                // 이 부분은 handleFocusOut에서 처리하므로 별도의 변환은 필요하지 않음
                return;
            }

        });

        /**
         * 수식 렌더링된 div를 클릭했을 때 편집 모드로 전환하는 이벤트 핸들러
         */
        editorContainer.addEventListener('click', (event) => {
            const target = event.target;
            if (target.classList.contains('equation')) {
                transformToEditableDiv(target);
            }
        });

        /**
         * 포커스 아웃(blur) 이벤트를 통해 수식 렌더링 트리거
         */
        editorContainer.addEventListener('focusout', (event) => {
            const target = event.target;
            if (target.classList.contains('editable') && !target.classList.contains('equation')) {
                handleFocusOut(target);
            }
        });

        /**
         * 구성 시작 시 플래그 설정
         */
        editorContainer.addEventListener('compositionstart', () => {
            isComposing = true;
        });

        /**
         * 구성 종료 시 플래그 해제 및 커서 위치 업데이트
         */
        editorContainer.addEventListener('compositionend', (event) => {
            isComposing = false;
            const target = event.target;
            if (target.classList.contains('editable')) {
                handleCaretPosition(target);
            }
        });

        /**
         * 커서 위치 업데이트 이벤트 핸들러 등록
         */
        const updateCaretEvents = ['keyup', 'click', 'input', 'mouseup'];
        updateCaretEvents.forEach(eventType => {
            editorContainer.addEventListener(eventType, (event) => {
                const target = event.target;
                if (target.classList.contains('editable')) {
                    handleCaretPosition(target);
                }
            });
        });

        /**
         * 페이지 로드 시 초기 커서 위치 설정
         */
        window.addEventListener('load', () => {
            const initialEditable = editorContainer.querySelector('.editable');
            handleCaretPosition(initialEditable);
            setCaretPosition(initialEditable, 0);
        });
    </script>
</body>

</html>